# TDD Patterns for tech-blog-website

## Red-Green-Refactor Cycle Implementation

### Phase 1: Red (Failing Test)
```typescript
// Example: Article creation test
describe('ArticleEditor', () => {
  it('should create new article with title and content', async () => {
    // Arrange
    const mockOnSave = jest.fn()
    render(<ArticleEditor onSave={mockOnSave} />)
    
    // Act
    fireEvent.change(screen.getByLabelText(/title/i), {
      target: { value: 'Test Article' }
    })
    fireEvent.change(screen.getByLabelText(/content/i), {
      target: { value: '# Test Content' }
    })
    fireEvent.click(screen.getByRole('button', { name: /save/i }))
    
    // Assert
    await waitFor(() => {
      expect(mockOnSave).toHaveBeenCalledWith({
        title: 'Test Article',
        content: '# Test Content',
        status: 'draft'
      })
    })
  })
})
```

### Phase 2: Green (Minimal Implementation)
```typescript
// Minimal implementation to pass test
interface ArticleEditorProps {
  onSave: (article: { title: string; content: string; status: string }) => void
}

const ArticleEditor: React.FC<ArticleEditorProps> = ({ onSave }) => {
  const [title, setTitle] = useState('')
  const [content, setContent] = useState('')
  
  const handleSave = () => {
    onSave({ title, content, status: 'draft' })
  }
  
  return (
    <div>
      <input
        aria-label="Title"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <textarea
        aria-label="Content"
        value={content}
        onChange={(e) => setContent(e.target.value)}
      />
      <button onClick={handleSave}>Save</button>
    </div>
  )
}
```

### Phase 3: Refactor (Improvement)
```typescript
// Refactored with proper types, validation, and optimization
interface Article {
  title: string
  content: string
  status: 'draft' | 'published'
  excerpt?: string
  tags?: string[]
}

interface ArticleEditorProps {
  initialArticle?: Partial<Article>
  onSave: (article: Article) => void
  isLoading?: boolean
}

const ArticleEditor: React.FC<ArticleEditorProps> = ({
  initialArticle = {},
  onSave,
  isLoading = false
}) => {
  const [article, setArticle] = useState<Partial<Article>>({
    title: '',
    content: '',
    status: 'draft',
    ...initialArticle
  })
  
  const handleSave = useCallback(() => {
    if (!article.title || !article.content) return
    
    onSave({
      title: article.title,
      content: article.content,
      status: article.status || 'draft',
      excerpt: article.excerpt,
      tags: article.tags
    })
  }, [article, onSave])
  
  const updateArticle = useCallback((updates: Partial<Article>) => {
    setArticle(prev => ({ ...prev, ...updates }))
  }, [])
  
  return (
    <form onSubmit={(e) => { e.preventDefault(); handleSave() }}>
      <div className="space-y-4">
        <Input
          label="Title"
          value={article.title || ''}
          onChange={(value) => updateArticle({ title: value })}
          required
        />
        <MarkdownEditor
          value={article.content || ''}
          onChange={(value) => updateArticle({ content: value })}
        />
        <Button
          type="submit"
          disabled={!article.title || !article.content || isLoading}
        >
          {isLoading ? 'Saving...' : 'Save'}
        </Button>
      </div>
    </form>
  )
}
```

## Test Patterns for Core Features

### 1. Markdown Editor Tests
```typescript
describe('MarkdownEditor', () => {
  // Real-time preview test
  it('should update preview when content changes', async () => {
    render(<MarkdownEditor />)
    
    const editor = screen.getByRole('textbox')
    fireEvent.change(editor, { target: { value: '# Heading' } })
    
    await waitFor(() => {
      expect(screen.getByText('Heading')).toBeInTheDocument()
    })
  })
  
  // Auto-save test
  it('should auto-save content every 3 minutes', async () => {
    jest.useFakeTimers()
    const mockAutoSave = jest.fn()
    
    render(<MarkdownEditor onAutoSave={mockAutoSave} autoSave />)
    
    const editor = screen.getByRole('textbox')
    fireEvent.change(editor, { target: { value: 'Content' } })
    
    jest.advanceTimersByTime(180000) // 3 minutes
    
    expect(mockAutoSave).toHaveBeenCalledWith('Content')
    jest.useRealTimers()
  })
  
  // Image upload test
  it('should handle image upload via drag and drop', async () => {
    const mockUpload = jest.fn().mockResolvedValue('/images/test.jpg')
    render(<MarkdownEditor onImageUpload={mockUpload} />)
    
    const file = new File([''], 'test.jpg', { type: 'image/jpeg' })
    const editor = screen.getByRole('textbox')
    
    fireEvent.drop(editor, { dataTransfer: { files: [file] } })
    
    await waitFor(() => {
      expect(mockUpload).toHaveBeenCalledWith(file)
    })
  })
})
```

### 2. API Route Tests
```typescript
// API integration tests
describe('/api/posts', () => {
  it('should create new post with valid data', async () => {
    const postData = {
      title: 'Test Post',
      content: '# Content',
      status: 'draft' as const
    }
    
    const { req, res } = createMocks({
      method: 'POST',
      body: postData
    })
    
    await handler(req, res)
    
    expect(res._getStatusCode()).toBe(201)
    const response = JSON.parse(res._getData())
    expect(response.post.title).toBe('Test Post')
    expect(response.post.status).toBe('draft')
  })
  
  it('should validate required fields', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: { content: 'Content only' } // Missing title
    })
    
    await handler(req, res)
    
    expect(res._getStatusCode()).toBe(400)
    const response = JSON.parse(res._getData())
    expect(response.error.code).toBe('VALIDATION_ERROR')
  })
})
```

### 3. Component Integration Tests
```typescript
describe('ArticleManager Integration', () => {
  it('should complete full article lifecycle', async () => {
    const user = userEvent.setup()
    
    render(<ArticleManager />)
    
    // Create article
    await user.click(screen.getByText('New Article'))
    await user.type(screen.getByLabelText(/title/i), 'Integration Test')
    await user.type(screen.getByLabelText(/content/i), '# Test Content')
    await user.click(screen.getByText('Save Draft'))
    
    // Verify draft creation
    await waitFor(() => {
      expect(screen.getByText('Integration Test')).toBeInTheDocument()
      expect(screen.getByText('Draft')).toBeInTheDocument()
    })
    
    // Publish article
    await user.click(screen.getByText('Publish'))
    
    // Verify publication
    await waitFor(() => {
      expect(screen.getByText('Published')).toBeInTheDocument()
    })
  })
})
```

## Test Data Patterns

### Factory Pattern for Test Data
```typescript
// Test data factories
export const ArticleFactory = {
  build: (overrides: Partial<Article> = {}): Article => ({
    id: faker.string.uuid(),
    title: faker.lorem.sentence(),
    content: faker.lorem.paragraphs(),
    excerpt: faker.lorem.paragraph(),
    status: 'draft',
    authorId: faker.string.uuid(),
    createdAt: faker.date.recent().toISOString(),
    updatedAt: faker.date.recent().toISOString(),
    tags: [faker.lorem.word(), faker.lorem.word()],
    ...overrides
  }),
  
  buildPublished: (overrides: Partial<Article> = {}): Article =>
    ArticleFactory.build({
      status: 'published',
      publishedAt: faker.date.recent().toISOString(),
      ...overrides
    }),
    
  buildMany: (count: number, overrides: Partial<Article> = {}): Article[] =>
    Array.from({ length: count }, () => ArticleFactory.build(overrides))
}
```

### Mock Service Patterns
```typescript
// Service mocks
export const mockSupabaseClient = {
  from: jest.fn(() => ({
    select: jest.fn(() => ({
      eq: jest.fn(() => ({
        single: jest.fn(() => Promise.resolve({
          data: ArticleFactory.build(),
          error: null
        }))
      }))
    })),
    insert: jest.fn(() => Promise.resolve({
      data: ArticleFactory.build(),
      error: null
    })),
    update: jest.fn(() => Promise.resolve({
      data: ArticleFactory.build(),
      error: null
    })),
    delete: jest.fn(() => Promise.resolve({
      error: null
    }))
  }))
}
```

## Test Utilities and Helpers

### Custom Render with Providers
```typescript
// Test utilities
import { render, RenderOptions } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ThemeProvider } from '@/contexts/ThemeContext'

const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false }
  }
})

interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {
  queryClient?: QueryClient
}

export const renderWithProviders = (
  ui: React.ReactElement,
  {
    queryClient = createTestQueryClient(),
    ...renderOptions
  }: CustomRenderOptions = {}
) => {
  const Wrapper = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        {children}
      </ThemeProvider>
    </QueryClientProvider>
  )
  
  return {
    ...render(ui, { wrapper: Wrapper, ...renderOptions }),
    queryClient
  }
}
```

### Async Testing Patterns
```typescript
// Async operation testing
export const waitForAsyncOperation = async (
  operation: () => Promise<void>,
  timeout = 5000
) => {
  await act(async () => {
    await operation()
  })
}

export const expectAsyncError = async (
  asyncFn: () => Promise<any>,
  expectedError: string
) => {
  await expect(asyncFn()).rejects.toThrow(expectedError)
}
```

## Performance Testing

### Component Performance Tests
```typescript
describe('MarkdownEditor Performance', () => {
  it('should handle large content without performance issues', () => {
    const largeContent = 'a'.repeat(50000)
    const startTime = performance.now()
    
    render(<MarkdownEditor initialValue={largeContent} />)
    
    const endTime = performance.now()
    expect(endTime - startTime).toBeLessThan(100) // Should render in < 100ms
  })
  
  it('should debounce onChange events', async () => {
    const mockOnChange = jest.fn()
    render(<MarkdownEditor onChange={mockOnChange} />)
    
    const editor = screen.getByRole('textbox')
    
    // Rapid changes
    fireEvent.change(editor, { target: { value: 'a' } })
    fireEvent.change(editor, { target: { value: 'ab' } })
    fireEvent.change(editor, { target: { value: 'abc' } })
    
    // Wait for debounce
    await waitFor(() => {
      expect(mockOnChange).toHaveBeenCalledTimes(1)
      expect(mockOnChange).toHaveBeenLastCalledWith('abc')
    }, { timeout: 1000 })
  })
})
```

This TDD pattern guide ensures consistent, high-quality test-driven development for the tech-blog-website project.